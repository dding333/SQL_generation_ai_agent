import os
import json
import pymysql
import pandas as pd
from googleapiclient.errors import HttpError
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.http import MediaIoBaseUpload
from io import BytesIO
import matplotlib
import seaborn as sns
import numpy as np
import inspect
import openai
import time


def sql_inter(sql_query, g='globals()'):
    """
    Executes an SQL query and returns the results. This function connects to a MySQL database, executes the query provided, and retrieves the output.

    :param sql_query: A string containing the SQL query to be executed on the telco_db database.
    :param g: Environment variable, default is 'globals()'.
    :return: The result of the executed SQL query as a JSON string.
    """
    mysql_pw = os.getenv('MYSQL_PW')

    connection = pymysql.connect(
        host='localhost',
        user='root',
        passwd=mysql_pw,
        db='telco_db',
        charset='utf8'
    )

    try:
        with connection.cursor() as cursor:
            cursor.execute(sql_query)
            results = cursor.fetchall()
    finally:
        connection.close()

    return json.dumps(results)


def extract_data(sql_query, df_name, g='globals()'):
    """
    Retrieves data from a MySQL table and saves it as a DataFrame in the local Python environment.

    :param sql_query: A string containing the SQL query used to extract data from the MySQL database.
    :param df_name: A string specifying the variable name under which the retrieved table will be stored.
    :param g: Environment variable, default is 'globals()'.
    :return: Confirmation message on successful data extraction and saving.
    """
    mysql_pw = os.getenv('MYSQL_PW')

    connection = pymysql.connect(
        host='localhost',
        user='root',
        passwd=mysql_pw,
        db='telco_db',
        charset='utf8'
    )

    g[df_name] = pd.read_sql(sql_query, connection)

    return f"Successfully created the variable: {df_name}"


def python_inter(py_code, g='globals()'):
    """
    Executes a segment of non-plotting Python code and returns the outcome. If the code involves plotting, use `fig_inter` instead.

    :param py_code: A string containing the Python code to be executed.
    :param g: Environment variable, default is 'globals()'.
    :return: The result of executing the Python code or an error message in case of failure.
    """
    initial_vars = set(g.keys())
    try:
        exec(py_code, g)
    except Exception as e:
        return f"Error during execution: {e}"

    new_vars = set(g.keys()) - initial_vars
    if new_vars:
        return str({var: g[var] for var in new_vars})

    try:
        return str(eval(py_code, g))
    except Exception as e:
        try:
            exec(py_code, g)
            return "Code executed successfully"
        except Exception as e:
            return f"Error during execution: {e}"


def upload_image_to_drive(figure, folder_id='1YstWRU-78JwTEQQA3vJokK3OF_F0djRH'):
    """
    Uploads a generated image to Google Drive.

    :param figure: A figure object (e.g., Matplotlib figure) to be uploaded.
    :param folder_id: Google Drive folder ID where the image will be uploaded.
    :return: A link to the uploaded image.
    """
    creds = Credentials.from_authorized_user_file('token.json')
    drive_service = build('drive', 'v3', credentials=creds)

    buf = BytesIO()
    figure.savefig(buf, format='png')
    buf.seek(0)
    media = MediaIoBaseUpload(buf, mimetype='image/png', resumable=True)

    file_metadata = {
        'name': 'UploadedImage.png',
        'parents': [folder_id],
        'mimeType': 'image/png'
    }

    image_file = drive_service.files().create(
        body=file_metadata,
        media_body=media,
        fields='id,webContentLink'
    ).execute()

    return image_file["webContentLink"]


def fig_inter(py_code, fname, g='globals()'):
    """
    Executes Python code that involves visualizations and returns an image-type object.

    :param py_code: A string containing Python code that generates plots. The code must generate a Figure object.
    :param fname: The name of the Figure object generated by the Python code, passed as a string.
    :param g: Environment variable, default is 'globals()'.
    :return: Result of the executed code and a link to the generated image if successfully uploaded.
    """
    current_backend = matplotlib.get_backend()
    matplotlib.use('Agg')

    import matplotlib.pyplot as plt
    import pandas as pd
    import seaborn as sns

    local_vars = {"plt": plt, "pd": pd, "sns": sns}

    try:
        exec(py_code, g, local_vars)
    except Exception as e:
        return f"Error during execution: {e}"

    matplotlib.use(current_backend)
    fig = local_vars[fname]

    try:
        fig_url = upload_image_to_drive(fig)
        return f"Code executed successfully, image uploaded to: {fig_url}"
    except Exception as e:
        return "Image upload failed. Please check folder ID and network."


def auto_functions(functions_list):
    """
    Generates the `functions` parameter for the Chat model.

    :param functions_list: A list of function objects.
    :return: A list of function descriptions formatted for the Chat model.
    """

    def generate_function_descriptions(functions_list):
        functions = []

        def chen_ming_algorithm(data):
            """
            Applies the Chen Ming algorithm to a dataset for special calculations.

            :param data: String representing the dataset to be processed.
            :return: The result of the Chen Ming algorithm as a JSON-formatted DataFrame.
            """
            df_new = pd.read_json(data)
            res = np.sum(df_new, axis=1) - 1
            return res.to_json(orient='records')

        chen_ming_function = {
            "name": "chen_ming_algorithm",
            "description": "Applies the Chen Ming algorithm for dataset calculations.",
            "parameters": {
                "type": "object",
                "properties": {
                    "data": {
                        "type": "string",
                        "description": "Dataset for Chen Ming algorithm."
                    }
                },
                "required": ["data"]
            }
        }

        for function in functions_list:
            function_description = inspect.getdoc(function)
            function_name = function.__name__

            assistant_message = json.dumps(chen_ming_function)
            user_prompt = (
                f"Now, there is another function called '{function_name}' with description: '{function_description}'. "
                "Please generate a function object for this function in the same format.")

            response = openai.ChatCompletion.create(
                model="gpt-4-0613",
                messages=[
                    {"role": "user", "name": "example_user", "content": user_prompt},
                    {"role": "assistant", "name": "example_assistant", "content": assistant_message}
                ]
            )
            functions.append(json.loads(response.choices[0].message['content']))
        return functions

    attempts = 0
    while attempts < 3:
        try:
            return generate_function_descriptions(functions_list)
        except Exception as e:
            attempts += 1
            print(f"Error: {e}. Retrying after 1 minute.")
            time.sleep(60)
            if attempts == 3:
                raise Exception("Maximum retry attempts reached.")


if __name__ == '__main__':
    print("This script contains functions to interface with MySQL and manage other utilities.")
